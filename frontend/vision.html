<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>企业视觉识别系统</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
    tailwind.config = {
        theme: {
            extend: {
                colors: {
                    primary: '#3B82F6',
                    secondary: '#10B981',
                    danger: '#EF4444',
                    dark: '#1E293B',
                },
                fontFamily: {
                    sans: ['Inter', 'system-ui', 'sans-serif'],
                },
            }
        }
    }
    </script>
    <style>
        .canvas-container {
            background-image: 
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .vector-shape {
            stroke-width: 2;
            fill-opacity: 0.8;
            stroke-opacity: 1;
            cursor: pointer;
            transition: transform 0.15s ease-out, filter 0.15s ease-out, opacity 0.15s ease-out;
            will-change: transform, filter;
        }
        .vector-shape.selected {
            cursor: grab;
        }
        .vector-shape:hover {
            stroke-width: 3;
            filter: brightness(1.1);
        }
        .vector-shape.selected {
            stroke-width: 4;
            stroke-dasharray: 8,4;
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.6));
        }
        .vector-shape.dragging {
            transition: none;
            will-change: transform;
        }
        .toast {
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
        }
        .toast.show {
            transform: translateX(0);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- 页眉 -->
    <header class="bg-white shadow-md sticky top-0 z-50">
        <div class="container mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center space-x-2">
                <i class="fa fa-camera text-primary text-2xl"></i>
                <h1 class="text-xl font-bold text-primary">企业视觉识别系统</h1>
            </div>
            <div class="flex items-center space-x-4">
                <a href="index.html" class="p-2 rounded-full hover:bg-gray-300 transition-colors duration-200" title="首页">
                    <i class="fa fa-home text-gray-600"></i>
                    <span class="ml-1 hidden sm:inline">首页</span>
                </a>
                <a href="vision.html" class="bg-gray-200 p-2 rounded-full hover:bg-gray-300 transition-colors duration-200" title="企业视觉识别系统">
                    <i class="fa fa-camera text-gray-600"></i>
                    <span class="ml-1 hidden sm:inline">企业视觉识别系统</span>
                </a>
                <button id="theme-toggle" class="p-2 rounded-full hover:bg-gray-100 transition-colors duration-200">
                    <i class="fa fa-moon-o text-gray-600"></i>
                </button>
                <button id="help-btn" class="p-2 rounded-full hover:bg-gray-100 transition-colors duration-200">
                    <i class="fa fa-question-circle text-gray-600"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Toast 提示容器 -->
    <div id="toast-container" class="fixed bottom-4 left-4 z-50 space-y-2"></div>
    
    <div class="container mx-auto px-4 py-8">
        <!-- 头部标题 -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">
                <i class="fa fa-palette mr-3"></i>企业视觉识别系统
            </h1>
            <p class="text-gray-600">基于 HEX 色彩空间的专业颜色管理系统</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
            <!-- 左侧：颜色空间管理 -->
            <div class="lg:col-span-1">
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">
                        <i class="fa fa-cog mr-2"></i>颜色空间配置
                    </h2>
                    
                    <!-- HEX 输入 -->
                    <div class="mb-6">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">HEX 颜色选择</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-2">颜色选择器</label>
                                <div class="flex items-center space-x-3">
                                    <input type="color" id="color-picker" value="#000000" 
                                           class="w-16 h-16 rounded-lg border-2 border-gray-300 cursor-pointer">
                                    <div class="flex-1">
                                        <input type="text" id="hex-input" placeholder="#000000" value="#000000"
                                               class="w-full px-3 py-2 border border-gray-300 rounded-md font-mono text-sm"
                                               pattern="^#[0-9A-Fa-f]{6}$">
                                        <div class="mt-2 text-xs text-gray-500">输入格式: #RRGGBB</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 保存颜色 -->
                    <div class="space-y-3 mb-3">
                        <div>
                            <label class="block text-sm font-medium text-gray-600 mb-2">颜色别名</label>
                            <input type="text" id="color-alias" placeholder="输入颜色别名（可选）" 
                                   class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                        </div>
                        <button onclick="saveColor()" 
                                class="w-full px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                            <i class="fa fa-save mr-2"></i>保存到调色板
                        </button>
                    </div>

                    <!-- 保存的调色板 -->
                    <div class="">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">企业调色板</h3>
                        <div id="color-palette" class="flex flex-wrap gap-2 justify-left">
                            <!-- 保存的颜色将在这里显示 -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- 中间：矢量画板 -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-semibold text-gray-800">
                            <i class="fa fa-vector-square mr-2"></i>矢量画板
                        </h2>
                        
                        <!-- 单位转换 -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-gray-600">单位:</label>
                            <select id="unit-select" onchange="updateCanvas()" 
                                    class="px-3 py-1 border border-gray-300 rounded-md text-sm">
                                <option value="point">Point</option>
                                <option value="mm">mm</option>
                                <option value="cm">cm</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- 画板工具栏 -->
                    <div class="mb-4 flex flex-wrap gap-2">
                        <button onclick="addShape('line')" 
                                class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm">
                            <i class="fa fa-minus mr-1"></i>直线
                        </button>
                        <button onclick="addShape('rect')" 
                                class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm">
                            <i class="fa fa-square mr-1"></i>矩形
                        </button>
                        <button onclick="addShape('circle')" 
                                class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm">
                            <i class="fa fa-circle mr-1"></i>圆形
                        </button>
                        <button onclick="clearCanvas()" 
                                class="px-3 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm">
                            <i class="fa fa-trash mr-1"></i>清空
                        </button>
                    </div>
                    
                    <!-- SVG 画板 -->
                    <div class="canvas-container rounded-lg border-2 border-gray-300 overflow-hidden">
                        <svg id="vector-canvas" width="100%" height="400" viewBox="0 0 800 400" 
                             class="bg-white">
                            <!-- 网格背景 -->
                            <defs>
                                <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                                    <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e5e7eb" stroke-width="1"/>
                                </pattern>
                            </defs>
                            <rect width="100%" height="100%" fill="url(#grid)" />
                            
                            <!-- 标尺 -->
                            <g id="rulers">
                                <!-- 水平标尺 -->
                                <line x1="0" y1="0" x2="800" y2="0" stroke="#6b7280" stroke-width="2"/>
                                <!-- 垂直标尺 -->
                                <line x1="0" y1="0" x2="0" y2="400" stroke="#6b7280" stroke-width="2"/>
                            </g>
                            
                            <!-- 动态形状将在这里添加 -->
                            <g id="shapes-container"></g>
                        </svg>
                    </div>
                </div>
            </div>
            
            <!-- 右侧：画板信息和属性面板 -->
            <div class="lg:col-span-1">
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">
                        <i class="fa fa-info-circle mr-2"></i>画板信息
                    </h2>
                    
                    <!-- 画板信息 -->
                    <div class="space-y-4 text-sm">
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-medium text-gray-700">画板尺寸</div>
                            <div id="canvas-size" class="text-gray-600">800 × 400 pt</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-medium text-gray-700">当前单位</div>
                            <div id="current-unit" class="text-gray-600">Point</div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="font-medium text-gray-700">形状数量</div>
                            <div id="shape-count" class="text-gray-600">0</div>
                        </div>
                    </div>
                    
                    <!-- 属性面板 -->
                    <div id="properties-panel" class="mt-6 bg-gray-50 rounded-lg p-4 hidden">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">
                            <i class="fa fa-edit mr-2"></i>形状属性
                        </h3>
                        <div id="properties-content" class="space-y-3">
                            <!-- 属性内容将动态生成 -->
                        </div>
                        <div class="mt-4 flex justify-end">
                            <button onclick="deleteSelectedShape()" 
                                    class="px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm mr-2">
                                <i class="fa fa-trash mr-1"></i>删除
                            </button>
                            <button onclick="deselectShape()" 
                                    class="px-3 py-1 bg-gray-500 text-white rounded-md hover:bg-gray-600 text-sm">
                                <i class="fa fa-times mr-1"></i>取消选择
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let savedColors = [];
        let shapeCounter = 0;
        let currentColor = '#000000';
        let currentDrawingMode = null;
        let drawingStartPoint = null;
        let tempShape = null;
        let selectedShape = null;
        
        // 拖拽相关变量
        let isDragging = false;
        let dragTarget = null;
        let dragStartPoint = null;
        let dragOriginalPosition = null;
        let dragAnimationId = null;
        let cachedCanvasRect = null;
        let cachedScaleX = null;
        let cachedScaleY = null;
        
        // 单位转换常量
        const UNIT_CONVERSION = {
            point: { toPoint: 1, toMm: 0.3528, toCm: 0.03528 },
            mm: { toPoint: 2.8346, toMm: 1, toCm: 0.1 },
            cm: { toPoint: 28.346, toMm: 10, toCm: 1 }
        };
        
        // 统一单位处理机制
        function convertUnit(value, fromUnit, toUnit) {
            if (fromUnit === toUnit) return value;
            
            // 先转换为点
            const valueInPoints = value * UNIT_CONVERSION[fromUnit].toPoint;
            
            // 再转换为目标单位
            return valueInPoints / UNIT_CONVERSION[toUnit].toPoint;
        }
        
        function convertPointToUnit(point, targetUnit) {
            const currentUnit = document.getElementById('unit-select').value;
            return {
                x: convertUnit(point.x, 'point', targetUnit),
                y: convertUnit(point.y, 'point', targetUnit)
            };
        }
        
        function convertUnitToPoint(unitPoint, sourceUnit) {
            return {
                x: convertUnit(unitPoint.x, sourceUnit, 'point'),
                y: convertUnit(unitPoint.y, sourceUnit, 'point')
            };
        }
        
        function getCurrentUnit() {
            return document.getElementById('unit-select').value;
        }
        
        function formatCoordinate(value, unit) {
            return value.toFixed(2) + ' ' + unit;
        }
        
        // 显示Toast提示
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            
            // 根据类型设置样式
            const typeStyles = {
                'info': 'bg-blue-500',
                'success': 'bg-green-500',
                'warning': 'bg-yellow-500',
                'error': 'bg-red-500'
            };
            
            const typeIcons = {
                'info': 'fa-info-circle',
                'success': 'fa-check-circle',
                'warning': 'fa-exclamation-triangle',
                'error': 'fa-times-circle'
            };
            
            toast.className = `toast ${typeStyles[type]} text-white px-4 py-3 rounded-lg shadow-lg flex items-center space-x-2 min-w-64`;
            toast.innerHTML = `
                <i class="fa ${typeIcons[type]}"></i>
                <span>${message}</span>
            `;
            
            toastContainer.appendChild(toast);
            
            // 触发动画
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // 3秒后自动移除
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }
        
        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            updateCanvas();
            loadSavedColors();
            addDragListenersToExistingShapes();
        });
        
        // 为现有图形添加拖拽事件监听器
        function addDragListenersToExistingShapes() {
            const existingShapes = document.querySelectorAll('.vector-shape');
            existingShapes.forEach(shape => {
                // 移除旧的监听器（如果存在）
                shape.removeEventListener('mousedown', handleShapeMouseDown);
                // 添加新的拖拽监听器
                shape.addEventListener('mousedown', handleShapeMouseDown);
            });
        }
        
        // 初始化事件监听器
        function initializeEventListeners() {
            // 颜色选择器事件
            document.getElementById('color-picker').addEventListener('input', updateColorFromPicker);
            document.getElementById('hex-input').addEventListener('input', updateColorFromHex);
            
            // 画板点击事件 - 用于交互式绘制
            const canvas = document.getElementById('vector-canvas');
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            
            // 拖拽事件监听器
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            // 点击空白区域取消选择形状
            canvas.addEventListener('click', function(event) {
                if (event.target === canvas || event.target.id === 'shapes-container') {
                    deselectShape();
                }
            });
            
            // 窗口大小改变事件
            window.addEventListener('resize', updateCanvas);
        }
        
        // CMYK 转 RGB
        function cmykToRgb(c, m, y, k) {
            c = c / 100;
            m = m / 100;
            y = y / 100;
            k = k / 100;
            
            const r = Math.round(255 * (1 - c) * (1 - k));
            const g = Math.round(255 * (1 - m) * (1 - k));
            const b = Math.round(255 * (1 - y) * (1 - k));
            
            return { r, g, b };
        }
        
        // RGB 转 HEX
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }
        
        // 从颜色选择器更新颜色
        function updateColorFromPicker() {
            const hex = document.getElementById('color-picker').value;
            updateColorDisplay(hex);
        }
        
        // 从 HEX 输入更新颜色
        function updateColorFromHex() {
            const hex = document.getElementById('hex-input').value;
            if (isValidHex(hex)) {
                updateColorDisplay(hex);
                document.getElementById('color-picker').value = hex;
            }
        }
        
        // 验证 HEX 格式
        function isValidHex(hex) {
            return /^#[0-9A-Fa-f]{6}$/.test(hex);
        }
        
        // 更新颜色显示
        function updateColorDisplay(hex) {
            currentColor = hex;
            document.getElementById('hex-input').value = hex;
        }
        

        

        
        // 保存颜色
        function saveColor() {
            const hexValue = document.getElementById('hex-input').value;
            const aliasInput = document.getElementById('color-alias');
            const alias = aliasInput.value.trim();
            
            const colorData = {
                id: Date.now(),
                hex: hexValue,
                alias: alias || hexValue, // 如果没有别名，使用hex值作为别名
                timestamp: new Date().toLocaleString()
            };
            
            savedColors.push(colorData);
            updateColorPalette();
            saveToLocalStorage();
            
            // 清空别名输入框
            aliasInput.value = '';
            showToast('颜色已保存到调色板', 'success');
        }
        
        // 更新调色板显示
        function updateColorPalette() {
            const palette = document.getElementById('color-palette');
            palette.innerHTML = '';
            
            savedColors.forEach(color => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'text-center';
                colorDiv.innerHTML = `
                    <div class="w-16 h-16 rounded-lg mx-auto mb-2 border-2 border-gray-300 cursor-pointer hover:scale-110 transition-transform" 
                         style="background-color: ${color.hex}" 
                         onclick="applyColor('${color.hex}')"
                         title="${color.alias} - ${color.hex}"></div>
                    <div class="text-xs font-medium text-gray-800 truncate" title="${color.alias}">${color.alias}</div>
                    <div class="text-xs font-mono text-gray-600">${color.hex}</div>
                    <button onclick="removeColor(${color.id})" class="mt-1 text-red-500 hover:text-red-700 text-xs">
                        <i class="fa fa-trash"></i>
                    </button>
                `;
                palette.appendChild(colorDiv);
            });
        }
        
        // 应用颜色到画板
        function applyColor(hex) {
            updateColorDisplay(hex);
            document.getElementById('color-picker').value = hex;
        }
        
        // HEX 转 RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // RGB 转 CMYK（简化版本）
        function rgbToCmyk(r, g, b) {
            r = r / 255;
            g = g / 255;
            b = b / 255;
            
            const k = 1 - Math.max(r, g, b);
            const c = (1 - r - k) / (1 - k) || 0;
            const m = (1 - g - k) / (1 - k) || 0;
            const y = (1 - b - k) / (1 - k) || 0;
            
            return { c: c * 100, m: m * 100, y: y * 100, k: k * 100 };
        }
        
        // 移除颜色
        function removeColor(id) {
            savedColors = savedColors.filter(color => color.id !== id);
            updateColorPalette();
            saveToLocalStorage();
        }
        
        // 形状选择处理
        function handleShapeClick(event) {
            event.stopPropagation();
            const shape = event.target;
            
            // 如果点击的是已经选中的形状，则取消选择
            if (selectedShape === shape) {
                deselectShape();
                return;
            }
            
            // 取消之前的选择
            if (selectedShape) {
                selectedShape.classList.remove('selected');
            }
            
            // 选择新形状
            selectedShape = shape;
            shape.classList.add('selected');
            
            // 显示属性面板
            showShapeProperties(shape);
            showToast('已选择形状', 'info');
        }
        
        // 显示形状属性
        function showShapeProperties(shape) {
            const panel = document.getElementById('properties-panel');
            const content = document.getElementById('properties-content');
            
            panel.classList.remove('hidden');
            
            // 获取当前单位
            const currentUnit = getCurrentUnit();
            
            const shapeType = shape.tagName;
            let propertiesHTML = '';
            
            // 通用属性
            const strokeColor = shape.getAttribute('stroke') || '#000000';
            const fillColor = shape.getAttribute('fill') || '#000000';
            const strokeWidth = shape.getAttribute('stroke-width') || '2';
            const fillOpacity = shape.getAttribute('fill-opacity') || '0.8';
            
            propertiesHTML += `
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="block text-sm font-medium text-gray-600 mb-1">边框颜色</label>
                        <input type="color" id="prop-stroke" value="${strokeColor}" 
                               onchange="updateShapeProperty('stroke', this.value)"
                               class="w-full h-8 rounded border border-gray-300">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-600 mb-1">填充颜色</label>
                        <input type="color" id="prop-fill" value="${fillColor}" 
                               onchange="updateShapeProperty('fill', this.value)"
                               class="w-full h-8 rounded border border-gray-300">
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="block text-sm font-medium text-gray-600 mb-1">边框宽度</label>
                        <input type="number" id="prop-stroke-width" value="${strokeWidth}" min="1" max="20"
                               onchange="updateShapeProperty('stroke-width', this.value)"
                               class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-600 mb-1">填充透明度</label>
                        <input type="range" id="prop-fill-opacity" value="${fillOpacity}" min="0" max="1" step="0.1"
                               onchange="updateShapeProperty('fill-opacity', this.value)"
                               class="w-full">
                        <div class="text-xs text-gray-500 text-center">${Math.round(fillOpacity * 100)}%</div>
                    </div>
                </div>
            `;
            
            // 根据形状类型添加特定属性
            switch(shapeType) {
                case 'rect':
                    const x = parseFloat(shape.getAttribute('x') || '0');
                    const y = parseFloat(shape.getAttribute('y') || '0');
                    const width = parseFloat(shape.getAttribute('width') || '0');
                    const height = parseFloat(shape.getAttribute('height') || '0');
                    
                    const xInUnit = convertUnit(x, 'point', currentUnit);
                    const yInUnit = convertUnit(y, 'point', currentUnit);
                    const widthInUnit = convertUnit(width, 'point', currentUnit);
                    const heightInUnit = convertUnit(height, 'point', currentUnit);
                    
                    propertiesHTML += `
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">X 坐标 (${currentUnit})</label>
                                <input type="number" id="prop-x" value="${xInUnit.toFixed(2)}" step="0.01"
                                       onchange="updateShapeProperty('x', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">Y 坐标 (${currentUnit})</label>
                                <input type="number" id="prop-y" value="${yInUnit.toFixed(2)}" step="0.01"
                                       onchange="updateShapeProperty('y', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">宽度 (${currentUnit})</label>
                                <input type="number" id="prop-width" value="${widthInUnit.toFixed(2)}" min="0.01" step="0.01"
                                       onchange="updateShapeProperty('width', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">高度 (${currentUnit})</label>
                                <input type="number" id="prop-height" value="${heightInUnit.toFixed(2)}" min="0.01" step="0.01"
                                       onchange="updateShapeProperty('height', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'circle':
                    const cx = parseFloat(shape.getAttribute('cx') || '0');
                    const cy = parseFloat(shape.getAttribute('cy') || '0');
                    const r = parseFloat(shape.getAttribute('r') || '0');
                    
                    const cxInUnit = convertUnit(cx, 'point', currentUnit);
                    const cyInUnit = convertUnit(cy, 'point', currentUnit);
                    const rInUnit = convertUnit(r, 'point', currentUnit);
                    
                    propertiesHTML += `
                        <div class="grid grid-cols-3 gap-3">
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">中心 X (${currentUnit})</label>
                                <input type="number" id="prop-cx" value="${cxInUnit.toFixed(2)}" step="0.01"
                                       onchange="updateShapeProperty('cx', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">中心 Y (${currentUnit})</label>
                                <input type="number" id="prop-cy" value="${cyInUnit.toFixed(2)}" step="0.01"
                                       onchange="updateShapeProperty('cy', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">半径 (${currentUnit})</label>
                                <input type="number" id="prop-r" value="${rInUnit.toFixed(2)}" min="0.01" step="0.01"
                                       onchange="updateShapeProperty('r', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'line':
                    const x1 = parseFloat(shape.getAttribute('x1') || '0');
                    const y1 = parseFloat(shape.getAttribute('y1') || '0');
                    const x2 = parseFloat(shape.getAttribute('x2') || '0');
                    const y2 = parseFloat(shape.getAttribute('y2') || '0');
                    
                    const x1InUnit = convertUnit(x1, 'point', currentUnit);
                    const y1InUnit = convertUnit(y1, 'point', currentUnit);
                    const x2InUnit = convertUnit(x2, 'point', currentUnit);
                    const y2InUnit = convertUnit(y2, 'point', currentUnit);
                    
                    propertiesHTML += `
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">起点 X (${currentUnit})</label>
                                <input type="number" id="prop-x1" value="${x1InUnit.toFixed(2)}" step="0.01"
                                       onchange="updateShapeProperty('x1', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">起点 Y (${currentUnit})</label>
                                <input type="number" id="prop-y1" value="${y1InUnit.toFixed(2)}" step="0.01"
                                       onchange="updateShapeProperty('y1', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">终点 X (${currentUnit})</label>
                                <input type="number" id="prop-x2" value="${x2InUnit.toFixed(2)}" step="0.01"
                                       onchange="updateShapeProperty('x2', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-600 mb-1">终点 Y (${currentUnit})</label>
                                <input type="number" id="prop-y2" value="${y2InUnit.toFixed(2)}" step="0.01"
                                       onchange="updateShapeProperty('y2', this.value, '${currentUnit}')"
                                       class="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                            </div>
                        </div>
                    `;
                    break;
            }
            
            content.innerHTML = propertiesHTML;
        }
        
        // 更新形状属性
        function updateShapeProperty(property, value, unit = 'point') {
            if (!selectedShape) return;
            
            // 如果是坐标或尺寸属性，需要进行单位转换
            const coordinateProperties = ['x', 'y', 'cx', 'cy', 'x1', 'y1', 'x2', 'y2', 'width', 'height', 'r'];
            
            if (coordinateProperties.includes(property)) {
                const numericValue = parseFloat(value);
                if (!isNaN(numericValue)) {
                    // 将输入的单位值转换为点
                    const valueInPoints = convertUnit(numericValue, unit, 'point');
                    selectedShape.setAttribute(property, valueInPoints);
                }
            } else {
                // 非坐标属性直接设置
                selectedShape.setAttribute(property, value);
            }
            
            // 如果更新的是填充透明度，同时更新显示的百分比
            if (property === 'fill-opacity') {
                const opacityDisplay = document.querySelector('#prop-fill-opacity + div');
                if (opacityDisplay) {
                    opacityDisplay.textContent = Math.round(value * 100) + '%';
                }
            }
            
            showToast(`已更新 ${property} 属性`, 'success');
        }
        
        // 取消选择形状
        function deselectShape() {
            if (selectedShape) {
                selectedShape.classList.remove('selected');
                selectedShape = null;
            }
            
            const panel = document.getElementById('properties-panel');
            panel.classList.add('hidden');
        }
        
        // 删除选中的形状
        function deleteSelectedShape() {
            if (!selectedShape) return;
            
            selectedShape.remove();
            selectedShape = null;
            
            const panel = document.getElementById('properties-panel');
            panel.classList.add('hidden');
            
            updateShapeCount();
            showToast('形状已删除', 'success');
        }
        
        // 添加形状到画板
        function addShape(type) {
            // 启动交互式绘制模式
            currentDrawingMode = type;
            drawingStartPoint = null;
            tempShape = null;
            
            const modeNames = {
                'line': '直线',
                'rect': '矩形',
                'circle': '圆形'
            };
            
            showToast(`请在画板上点击并拖拽来绘制${modeNames[type]}`, 'info');
            return;
            
            const container = document.getElementById('shapes-container');
            const shape = document.createElementNS('http://www.w3.org/2000/svg', 
                type === 'circle' ? 'circle' : type === 'triangle' ? 'polygon' : type === 'line' ? 'line' : 'rect');
            
            shape.setAttribute('class', 'vector-shape');
            shape.setAttribute('stroke', currentColor);
            shape.setAttribute('fill', currentColor);
            shape.setAttribute('id', 'shape-' + (++shapeCounter));
            
            const unit = document.getElementById('unit-select').value;
            const conversion = UNIT_CONVERSION[unit];
            
            switch(type) {
                case 'rect':
                    shape.setAttribute('x', Math.random() * 600 + 100);
                    shape.setAttribute('y', Math.random() * 300 + 50);
                    shape.setAttribute('width', 100 * conversion.toPoint);
                    shape.setAttribute('height', 60 * conversion.toPoint);
                    break;
                case 'circle':
                    shape.setAttribute('cx', Math.random() * 600 + 100);
                    shape.setAttribute('cy', Math.random() * 300 + 50);
                    shape.setAttribute('r', 40 * conversion.toPoint);
                    break;

                case 'line':
                    const x1 = Math.random() * 600 + 100;
                    const y1 = Math.random() * 300 + 50;
                    const x2 = x1 + Math.random() * 200 - 100;
                    const y2 = y1 + Math.random() * 200 - 100;
                    shape.setAttribute('x1', x1);
                    shape.setAttribute('y1', y1);
                    shape.setAttribute('x2', x2);
                    shape.setAttribute('y2', y2);
                    shape.setAttribute('fill', 'none');
                    shape.setAttribute('stroke-width', 3);
                    break;
            }
            
            container.appendChild(shape);
            updateShapeCount();
        }
        
        // 清空画板
        function clearCanvas() {
            const container = document.getElementById('shapes-container');
            container.innerHTML = '';
            shapeCounter = 0;
            updateShapeCount();
        }
        
        // 更新画板
        function updateCanvas() {
            const unit = getCurrentUnit();
            
            // 更新画板尺寸显示
            const widthInUnit = convertUnit(800, 'point', unit);
            const heightInUnit = convertUnit(400, 'point', unit);
            document.getElementById('canvas-size').textContent = `${widthInUnit.toFixed(1)} × ${heightInUnit.toFixed(1)} ${unit}`;
            document.getElementById('current-unit').textContent = unit.charAt(0).toUpperCase() + unit.slice(1);
            
            // 如果当前有选中的形状，刷新其属性显示以反映新单位
            if (selectedShape) {
                showShapeProperties(selectedShape);
            }
        }
        
        // 更新形状数量
        function updateShapeCount() {
            const count = document.querySelectorAll('#shapes-container > *').length;
            document.getElementById('shape-count').textContent = count;
        }
        
        // 处理画板点击事件
        function handleCanvasClick(event) {
            if (!currentDrawingMode) return;
            
            const canvas = document.getElementById('vector-canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = 800 / rect.width;
            const scaleY = 400 / rect.height;
            
            // 获取鼠标在画布上的坐标（以点为单位）
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            
            if (!drawingStartPoint) {
                // 第一次点击，设置起点
                drawingStartPoint = { x, y };
                
                // 创建临时预览图形
                createTempShape(x, y);
            } else {
                // 第二次点击，完成图形绘制
                finishShapeDrawing(x, y);
            }
        }
        
        // 处理画板鼠标移动事件
        function handleCanvasMouseMove(event) {
            if (!currentDrawingMode || !drawingStartPoint || !tempShape) return;
            
            const canvas = document.getElementById('vector-canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = 800 / rect.width;
            const scaleY = 400 / rect.height;
            
            // 获取鼠标在画布上的坐标（以点为单位）
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            
            // 更新临时预览图形
            updateTempShape(x, y);
        }
        
        // 创建临时预览图形
        function createTempShape(x, y) {
            const container = document.getElementById('shapes-container');
            
            switch(currentDrawingMode) {
                case 'line':
                    tempShape = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tempShape.setAttribute('x1', x);
                    tempShape.setAttribute('y1', y);
                    tempShape.setAttribute('x2', x);
                    tempShape.setAttribute('y2', y);
                    tempShape.setAttribute('stroke', currentColor);
                    tempShape.setAttribute('stroke-width', 3);
                    tempShape.setAttribute('fill', 'none');
                    break;
                    
                case 'rect':
                    tempShape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    tempShape.setAttribute('x', x);
                    tempShape.setAttribute('y', y);
                    tempShape.setAttribute('width', 0);
                    tempShape.setAttribute('height', 0);
                    tempShape.setAttribute('stroke', currentColor);
                    tempShape.setAttribute('fill', currentColor);
                    tempShape.setAttribute('fill-opacity', '0.3');
                    break;
                    
                case 'circle':
                    tempShape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    tempShape.setAttribute('cx', x);
                    tempShape.setAttribute('cy', y);
                    tempShape.setAttribute('r', 0);
                    tempShape.setAttribute('stroke', currentColor);
                    tempShape.setAttribute('fill', currentColor);
                    tempShape.setAttribute('fill-opacity', '0.3');
                    break;
                    

            }
            
            // 设置通用预览样式
            tempShape.setAttribute('stroke-dasharray', '5,5');
            tempShape.setAttribute('opacity', '0.7');
            tempShape.setAttribute('id', 'temp-shape');
            
            container.appendChild(tempShape);
        }
        
        // 更新临时预览图形
        function updateTempShape(x, y) {
            const startX = drawingStartPoint.x;
            const startY = drawingStartPoint.y;
            
            switch(currentDrawingMode) {
                case 'line':
                    tempShape.setAttribute('x2', x);
                    tempShape.setAttribute('y2', y);
                    break;
                    
                case 'rect':
                    const width = Math.abs(x - startX);
                    const height = Math.abs(y - startY);
                    const rectX = Math.min(startX, x);
                    const rectY = Math.min(startY, y);
                    tempShape.setAttribute('x', rectX);
                    tempShape.setAttribute('y', rectY);
                    tempShape.setAttribute('width', width);
                    tempShape.setAttribute('height', height);
                    break;
                    
                case 'circle':
                    const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                    tempShape.setAttribute('r', radius);
                    break;
                    

            }
        }
        
        // 获取图形类型名称
        function getShapeTypeName(shapeType) {
            switch(shapeType) {
                case 'line':
                    return '直线';
                case 'rect':
                    return '矩形';
                case 'circle':
                    return '圆形';
                default:
                    return '图形';
            }
        }
        
        // 完成图形绘制
        function finishShapeDrawing(endX, endY) {
            // 移除临时预览图形
            if (tempShape) {
                tempShape.remove();
                tempShape = null;
            }
            
            // 创建最终的图形
            const container = document.getElementById('shapes-container');
            const shape = document.createElementNS('http://www.w3.org/2000/svg', currentDrawingMode);
            
            const startX = drawingStartPoint.x;
            const startY = drawingStartPoint.y;
            
            // 获取当前绘图设置
            const colorPicker = document.getElementById('color-picker');
            const currentColor = colorPicker ? colorPicker.value : '#000000';
            const currentStrokeColor = currentColor; // 使用相同颜色作为边框色
            const currentStrokeWidth = '2'; // 默认边框宽度
            const currentFillOpacity = '0.8'; // 默认填充透明度
            
            switch(currentDrawingMode) {
                case 'line':
                    shape.setAttribute('x1', startX);
                    shape.setAttribute('y1', startY);
                    shape.setAttribute('x2', endX);
                    shape.setAttribute('y2', endY);
                    shape.setAttribute('stroke', currentStrokeColor);
                    shape.setAttribute('stroke-width', currentStrokeWidth);
                    shape.setAttribute('fill', 'none');
                    break;
                    
                case 'rect':
                    const width = Math.abs(endX - startX);
                    const height = Math.abs(endY - startY);
                    const rectX = Math.min(startX, endX);
                    const rectY = Math.min(startY, endY);
                    shape.setAttribute('x', rectX);
                    shape.setAttribute('y', rectY);
                    shape.setAttribute('width', width);
                    shape.setAttribute('height', height);
                    shape.setAttribute('stroke', currentStrokeColor);
                    shape.setAttribute('fill', currentColor);
                    shape.setAttribute('fill-opacity', currentFillOpacity);
                    break;
                    
                case 'circle':
                    const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    shape.setAttribute('cx', startX);
                    shape.setAttribute('cy', startY);
                    shape.setAttribute('r', radius);
                    shape.setAttribute('stroke', currentStrokeColor);
                    shape.setAttribute('fill', currentColor);
                    shape.setAttribute('fill-opacity', currentFillOpacity);
                    break;
                    

            }
            
            shape.setAttribute('class', 'vector-shape');
            shape.setAttribute('id', 'shape-' + (++shapeCounter));
            
            // 添加点击事件监听器
            shape.addEventListener('click', handleShapeClick);
            
            // 添加拖拽事件监听器
            shape.addEventListener('mousedown', handleShapeMouseDown);
            
            container.appendChild(shape);
            updateShapeCount();
            
            // 保存颜色到本地存储
            saveToLocalStorage();
            
            showToast(`已创建 ${getShapeTypeName(currentDrawingMode)}`, 'success');
            
            // 重置绘制状态
            currentDrawingMode = null;
            drawingStartPoint = null;
        }
        
        // 本地存储
        function saveToLocalStorage() {
            localStorage.setItem('enterpriseColors', JSON.stringify(savedColors));
        }
        
        function loadSavedColors() {
            const saved = localStorage.getItem('enterpriseColors');
            if (saved) {
                savedColors = JSON.parse(saved);
                // 为现有颜色添加别名字段（向后兼容）
                savedColors = savedColors.map(color => {
                    if (!color.alias) {
                        color.alias = color.hex; // 如果没有别名，使用hex值作为别名
                    }
                    return color;
                });
                updateColorPalette();
            }
        }
        
        // 拖拽功能函数
        
        // 处理形状鼠标按下事件（开始拖拽）
        function handleShapeMouseDown(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const shape = event.target;
            
            // 如果点击的是已经选中的形状，则开始拖拽
            if (selectedShape === shape) {
                isDragging = true;
                dragTarget = shape;
                
                const canvas = document.getElementById('vector-canvas');
                cachedCanvasRect = canvas.getBoundingClientRect();
                cachedScaleX = 800 / cachedCanvasRect.width;
                cachedScaleY = 400 / cachedCanvasRect.height;
                
                // 获取鼠标在画布上的坐标（以点为单位）
                const mouseX = (event.clientX - cachedCanvasRect.left) * cachedScaleX;
                const mouseY = (event.clientY - cachedCanvasRect.top) * cachedScaleY;
                
                dragStartPoint = { x: mouseX, y: mouseY };
                dragOriginalPosition = getShapePosition(shape);
                
                // 设置拖拽样式
                shape.classList.add('dragging');
                shape.style.cursor = 'grabbing';
                shape.style.opacity = '0.8';
                
                // 添加拖拽时的视觉反馈
                shape.style.filter = 'drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3))';
                
                // 确保图形可聚焦
                shape.setAttribute('tabindex', '0');
                
                showToast('开始拖拽图形', 'info');
                
                // 开始动画循环
                startDragAnimation();
            }
        }
        
        // 处理鼠标按下事件
        function handleMouseDown(event) {
            // 这个函数用于处理画布级别的鼠标按下事件
            // 实际的拖拽逻辑在 handleShapeMouseDown 中处理
        }
        
        // 处理鼠标移动事件
        function handleMouseMove(event) {
            if (!isDragging || !dragTarget) return;
            
            // 使用缓存的计算结果
            const mouseX = (event.clientX - cachedCanvasRect.left) * cachedScaleX;
            const mouseY = (event.clientY - cachedCanvasRect.top) * cachedScaleY;
            
            // 计算移动偏移量
            const deltaX = mouseX - dragStartPoint.x;
            const deltaY = mouseY - dragStartPoint.y;
            
            // 存储当前偏移量供动画循环使用
            dragTarget._pendingDeltaX = deltaX;
            dragTarget._pendingDeltaY = deltaY;
        }
        
        // 开始拖拽动画循环
        function startDragAnimation() {
            if (dragAnimationId) {
                cancelAnimationFrame(dragAnimationId);
            }
            
            function animate() {
                if (!isDragging || !dragTarget) {
                    dragAnimationId = null;
                    return;
                }
                
                // 检查是否有待处理的偏移量
                if (dragTarget._pendingDeltaX !== undefined || dragTarget._pendingDeltaY !== undefined) {
                    const deltaX = dragTarget._pendingDeltaX || 0;
                    const deltaY = dragTarget._pendingDeltaY || 0;
                    
                    // 批量更新图形位置
                    updateShapePositionOptimized(dragTarget, dragOriginalPosition, deltaX, deltaY);
                    
                    // 清除待处理的偏移量
                    dragTarget._pendingDeltaX = undefined;
                    dragTarget._pendingDeltaY = undefined;
                }
                
                dragAnimationId = requestAnimationFrame(animate);
            }
            
            dragAnimationId = requestAnimationFrame(animate);
        }
        
        // 处理鼠标释放事件
        function handleMouseUp(event) {
            if (isDragging && dragTarget) {
                // 停止动画循环
                if (dragAnimationId) {
                    cancelAnimationFrame(dragAnimationId);
                    dragAnimationId = null;
                }
                
                // 恢复图形样式
                dragTarget.classList.remove('dragging');
                dragTarget.style.cursor = 'grab';
                dragTarget.style.opacity = '1';
                dragTarget.style.filter = '';
                
                // 确保图形保持选中状态和焦点
                if (selectedShape === dragTarget) {
                    // 重新应用选中样式
                    dragTarget.classList.add('selected');
                    
                    // 刷新属性面板以显示新的位置
                    showShapeProperties(dragTarget);
                    
                    // 确保焦点在当前图形上
                    setTimeout(() => {
                        if (dragTarget) {
                            dragTarget.focus();
                            // 添加一个微妙的动画效果来确认拖拽完成
                            dragTarget.style.transform = 'scale(1.05)';
                            setTimeout(() => {
                                if (dragTarget) {
                                    dragTarget.style.transform = 'scale(1)';
                                }
                            }, 150);
                        }
                    }, 10);
                }
                
                showToast('图形拖拽完成', 'success');
            }
            
            // 重置拖拽状态
            isDragging = false;
            dragTarget = null;
            dragStartPoint = null;
            dragOriginalPosition = null;
            cachedCanvasRect = null;
            cachedScaleX = null;
            cachedScaleY = null;
        }
        
        // 获取图形位置
        function getShapePosition(shape) {
            const shapeType = shape.tagName;
            
            switch(shapeType) {
                case 'rect':
                    return {
                        x: parseFloat(shape.getAttribute('x') || 0),
                        y: parseFloat(shape.getAttribute('y') || 0)
                    };
                    
                case 'circle':
                    return {
                        cx: parseFloat(shape.getAttribute('cx') || 0),
                        cy: parseFloat(shape.getAttribute('cy') || 0)
                    };
                    
                case 'line':
                    return {
                        x1: parseFloat(shape.getAttribute('x1') || 0),
                        y1: parseFloat(shape.getAttribute('y1') || 0),
                        x2: parseFloat(shape.getAttribute('x2') || 0),
                        y2: parseFloat(shape.getAttribute('y2') || 0)
                    };
                    
                default:
                    return { x: 0, y: 0 };
            }
        }
        
        // 更新图形位置（优化版本）
        function updateShapePositionOptimized(shape, originalPosition, deltaX, deltaY) {
            const shapeType = shape.tagName;
            
            // 使用文档片段减少重绘
            const fragment = document.createDocumentFragment();
            
            switch(shapeType) {
                case 'rect':
                    const newX = originalPosition.x + deltaX;
                    const newY = originalPosition.y + deltaY;
                    
                    // 边界检查
                    const width = parseFloat(shape.getAttribute('width') || 0);
                    const height = parseFloat(shape.getAttribute('height') || 0);
                    
                    // 批量更新属性
                    const rectUpdates = {};
                    if (newX >= 0 && newX + width <= 800) {
                        rectUpdates.x = newX;
                    }
                    if (newY >= 0 && newY + height <= 400) {
                        rectUpdates.y = newY;
                    }
                    
                    // 一次性应用所有更新
                    Object.keys(rectUpdates).forEach(attr => {
                        shape.setAttribute(attr, rectUpdates[attr]);
                    });
                    break;
                    
                case 'circle':
                    const newCx = originalPosition.cx + deltaX;
                    const newCy = originalPosition.cy + deltaY;
                    const radius = parseFloat(shape.getAttribute('r') || 0);
                    
                    // 边界检查
                    const circleUpdates = {};
                    if (newCx - radius >= 0 && newCx + radius <= 800) {
                        circleUpdates.cx = newCx;
                    }
                    if (newCy - radius >= 0 && newCy + radius <= 400) {
                        circleUpdates.cy = newCy;
                    }
                    
                    // 一次性应用所有更新
                    Object.keys(circleUpdates).forEach(attr => {
                        shape.setAttribute(attr, circleUpdates[attr]);
                    });
                    break;
                    
                case 'line':
                    const newX1 = originalPosition.x1 + deltaX;
                    const newY1 = originalPosition.y1 + deltaY;
                    const newX2 = originalPosition.x2 + deltaX;
                    const newY2 = originalPosition.y2 + deltaY;
                    
                    // 边界检查
                    const lineUpdates = {};
                    if (newX1 >= 0 && newX1 <= 800 && newX2 >= 0 && newX2 <= 800) {
                        lineUpdates.x1 = newX1;
                        lineUpdates.x2 = newX2;
                    }
                    if (newY1 >= 0 && newY1 <= 400 && newY2 >= 0 && newY2 <= 400) {
                        lineUpdates.y1 = newY1;
                        lineUpdates.y2 = newY2;
                    }
                    
                    // 一次性应用所有更新
                    Object.keys(lineUpdates).forEach(attr => {
                        shape.setAttribute(attr, lineUpdates[attr]);
                    });
                    break;
            }
        }
        
        // 保持原有的 updateShapePosition 函数以兼容其他代码
        function updateShapePosition(shape, originalPosition, deltaX, deltaY) {
            updateShapePositionOptimized(shape, originalPosition, deltaX, deltaY);
        }
    </script>
</body>
</html>